---
title: "Kory"
author: "Kory Rosen"
date: "2024-03-10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(RPostgres)
library(stringr)
library(jsonlite)

creds <- read_json("credentials.json")

con <- dbConnect(Postgres(),
                 host = creds$host,
                 port = creds$port,
                 dbname = creds$dbname,
                 user = creds$user,
                 password = creds$password)

query <- "SELECT * FROM public.feather2"
data <- dbGetQuery(con, query)

# Work with the data

dbDisconnect(con)
```



 
```{r}

library(shiny)
library(ggplot2)
library(dplyr)
library(broom)
library(stringr)
library(tm)
library(wordcloud2)
library(plotly)
library(syuzhet)
library(DT)
library(shinyWidgets)
library(topicmodels)

data$opinions_text <- lapply(data$opinions_text, unlist)

# Preprocess the data
data$opinions_text <- str_remove_all(data$opinions_text, "\\[|\\]|'")
```

```{r}
library(shiny)
library(ggplot2)
library(dplyr)
library(broom)
library(stringr)
library(tm)
library(future)
library(wordcloud2)
library(plotly)
library(syuzhet)
library(DT)
library(shinyWidgets)
library(topicmodels)

data$opinions_text <- lapply(data$opinions_text, unlist)

# Preprocess the data
data$opinions_text <- str_remove_all(data$opinions_text, "\\[|\\]|'")

data2 <- data
data2$sub_opinions <- as.character(data2$sub_opinions)

clean_and_split_text <- function(text_vector) {
  all_sections <- list()
  
  for (text_element in 1:length(text_vector)) {
    text_element <- text_vector[text_element]
    # Replace the specific pattern \",\" with a unique delimiter, e.g., "|||"
    temp_text <- gsub("\\\",\\\"", "|||", text)

    # Split the text using the unique delimiter
    split_result <- strsplit(temp_text, "\\|\\|\\|")
    
    if (length(split_result) > 0) {
      hi <- split_result[[1]]
      hi <- lapply(hi, function(x) gsub("^\\{\"", "", x))
      hi <- lapply(hi, function(x) gsub("\\\"\\}$", "", x))
      
      split_word <- "SUPREME COURT OF THE UNITED STATES"
      delimiter <- "@@@SPLIT_HERE@@@"
      
      text_with_delimiter <- lapply(hi, function(text) {
        str_replace_all(text, fixed(split_word), paste0(delimiter, split_word))
      })
      
      sections <- lapply(text_with_delimiter, function(text) {
        unlist(strsplit(text, delimiter))
      })
      
      sections <- lapply(sections, function(section) {
        unique(section[section != ""])
      })
      
      all_sections <- c(all_sections, unlist(sections))
    }
  }

  return(unique(all_sections))
}

extract_author_name <- function(text) {
  pattern <- "JUSTICE\\s(\\w+)"
  last_names <- str_extract_all(text, pattern)[[1]]
  
  if (length(last_names) > 0) {
    last_names <- str_replace_all(last_names, "JUSTICE\\s", "")
    # Convert the last names to title case to match the format in author_info
    last_names <- tools::toTitleCase(last_names)
    # Return the first last name from the list
    return(last_names[1])
  }
  
  return(NA)
}

extract_author <- function(opinion_text, author_info) {
  author_last_name <- extract_author_name(opinion_text)
  
  opinion_attributes <- list(
    author_id = NA,
    full_name = NA,
    date_dob = NA,
    date_left = NA,
    date_start = NA,
    political_party = NA
  )
  
  if (!is.na(author_last_name)) {
    # Find the corresponding row in author_info based on the last name
    author_row <- author_info[author_info$last_name == author_last_name, ]
    
    if (nrow(author_row) > 0) {
      opinion_attributes$author_id <- author_row$author_id[1]
      opinion_attributes$full_name <- author_row$full_name[1]
      opinion_attributes$date_dob <- author_row$date_dob[1]
      opinion_attributes$date_left <- author_row$date_left[1]
      opinion_attributes$date_start <- author_row$date_start[1]
      opinion_attributes$political_party <- author_row$political_party[1]
    }
  }
  
  return(opinion_attributes)
}

new_rows <- list()

data2$original <- TRUE
data2$text_type <- "Default"

author_info <- data2 %>%
  group_by(full_name) %>%
  summarize(
    author_id = first(author_id),
    date_dob = first(date_dob),
    date_left = first(date_left),
    date_start = first(date_start),
    political_party = first(political_party)
  ) %>%
  ungroup()

# Define a function to extract the last name
extract_last_name <- function(full_name) {
  name_parts <- strsplit(full_name, " ")[[1]]
  last_name <- name_parts[length(name_parts)]
  
  # Handle suffixes like "jr" by using the second-to-last word as the last name
  if (tolower(last_name) %in% c("jr", "sr", "ii", "iii")) {
    last_name <- name_parts[length(name_parts) - 1]
  }
  
  return(toupper(last_name))
}

# Apply the function to the full names in author_info
author_info$last_name <- sapply(author_info$full_name, extract_last_name)

# Create a lookup table
lookup_table <- author_info %>% select(last_name, full_name)

# Iterate over each row in the dataframe
for (i in 1:nrow(data2)) {
  # Apply the cleaning and splitting function to the opinions_text column
  text <- data2$opinions_text[i]
  sections <- clean_and_split_text(text)
  
  for (section in sections) {
    new_row <- data2[i, ]
    new_row$original <- FALSE
    new_row$opinions_text <- section
    
    if (is.na(section)) next
    
    if (startsWith(section, "SUPREME COURT OF THE UNITED STATES Syllabus")) {
      new_row$text_type <- "Syllabus"
      new_row$full_name <- NA
      new_row$date_start <- NA
      new_row$date_dob <- NA
      new_row$political_party <- NA
      new_row$date_left <- NA
      new_row$author_id <- NA
      
    } else if (grepl("opinion of the court", section, ignore.case = TRUE)) {
      new_row$text_type <- "Opinion of the Court"
    } else if (grepl("concurring", section, ignore.case = TRUE)) {
      new_row$text_type <- "Concurring Opinion"
      opinion_attributes <- extract_author(section, author_info)
      new_row$author_id <- opinion_attributes$author_id
      new_row$full_name <- opinion_attributes$full_name
      new_row$date_dob <- opinion_attributes$date_dob
      new_row$date_left <- opinion_attributes$date_left
      new_row$date_start <- opinion_attributes$date_start
      new_row$political_party <- opinion_attributes$political_party
    } else if (grepl("dissenting", section, ignore.case = TRUE)) {
      new_row$text_type <- "Dissenting Opinion"
      opinion_attributes <- extract_author(section, author_info)
      new_row$author_id <- opinion_attributes$author_id
      new_row$full_name <- opinion_attributes$full_name
      new_row$date_dob <- opinion_attributes$date_dob
      new_row$date_left <- opinion_attributes$date_left
      new_row$date_start <- opinion_attributes$date_start
      new_row$political_party <- opinion_attributes$political_party
    } else {
      new_row$text_type <- "Other"
      new_row$full_name <- NA
      new_row$date_start <- NA
      new_row$date_dob <- NA
      new_row$political_party <- NA
      new_row$date_left <- NA
      new_row$author_id <- NA
    }
    
    new_rows <- c(new_rows, list(new_row))
  }
}

# Combine the new rows with the original dataframe
data2 <- bind_rows(data2, do.call(rbind, new_rows))

data2 <- data2[data2$original == FALSE, ]

data2 <- unique(data2)
rownames(data2) <- NULL

# Calculate the word count
data2$word_count <- sapply(strsplit(data2$opinions_text, " "), length)

# Remove metadata texts and Slip Opinion text
data2 <- data2[data2$word_count > 74, ]
data2 <- data2[!data2$word_count %in% c(125, 126, 127, 128, 129), ]
```

```{r}
library(tidyverse)
library(shinyjs)
library(data.table)
library(quanteda)
library(future)

ui <- fluidPage(
  useShinyjs(),
  titlePanel("Supreme Court Opinions Analysis"),
  
  sidebarLayout(
    sidebarPanel(
      selectInput("author", "Select Author:", 
                  choices = c("All", unique(data2$full_name))),
      dateRangeInput("year_range", "Select Year Range:",
                     start = min(data2$date_filed), end = max(data2$date_filed),
                     format = "yyyy-mm-dd"),
      pickerInput("decision_type", "Select Decision Type:",
                  choices = unique(data2$decision),
                  multiple = TRUE,
                  options = list(`actions-box` = TRUE)),
      pickerInput("text_type", "Select Text Type:",
                  choices = unique(data2$text_type),
                  multiple = TRUE,
                  options = list(`actions-box` = TRUE)),
      pickerInput("political_party", "Select Political Leaning of Opinion writer:",
                  choices = unique(data2$political_party),
                  multiple = TRUE,
                  options = list(`actions-box` = TRUE)),
      selectizeInput("case_name", "Select Case Name:",
                     choices = unique(data2$case_name),
                     multiple = TRUE,
                     options = list(placeholder = "Select case(s)"))
    ),
    
    mainPanel(
      tabsetPanel(
        tabPanel("Opinion Length",
                 plotlyOutput("opinion_length_plot"),
                 textOutput("opinion_length_avg")),
        tabPanel("Decision Types",
                 plotlyOutput("decision_types_plot")),
        tabPanel("Interactive Word Cloud",
                 wordcloud2Output("interactive_word_cloud")),
        tabPanel("Sentiment Analysis",
                 plotOutput("sentiment_plot")),
        tabPanel("data Table",
                 DTOutput("opinions_table"))
      )
    )
  )
)

server <- function(input, output) {
  options(shiny.http.response.timeout = 300)
  
  observe({
    selected_text_type <- input$text_type
    
    if ("Syllabus" %in% selected_text_type || "Other" %in% selected_text_type) {
      shinyjs::hide("author")
      shinyjs::hide("political_party")
    } else {
      shinyjs::show("author")
      shinyjs::show("political_party")
    }
  })
  
  filtered_data2 <- reactive({
        data2_filtered <- data2
    
    if (input$author != "All" && !("Syllabus" %in% input$text_type)) {
      data2_filtered <- data2_filtered %>% filter(full_name == input$author)
    }
    
    data2_filtered <- data2_filtered %>%
      filter(date_filed >= input$year_range[1] & date_filed <= input$year_range[2])
    
    if (!is.null(input$decision_type) && length(input$decision_type) > 0) {
      data2_filtered <- data2_filtered %>% filter(decision %in% input$decision_type)
    }
    
    if (!is.null(input$text_type) && length(input$text_type) > 0) {
      data2_filtered <- data2_filtered %>% filter(text_type %in% input$text_type)
    }
    
    if (!is.null(input$political_party) && length(input$political_party) > 0 && !("Syllabus" %in% input$text_type)) {
      data2_filtered <- data2_filtered %>% filter(political_party %in% input$political_party)
    }
    
    if (!is.null(input$case_name) && length(input$case_name) > 0) {
      data2_filtered <- data2_filtered %>% filter(case_name %in% input$case_name)
    }
    
    data2_filtered
  })
  
  
  output$opinion_length_plot <- renderPlotly({
    plot_ly(filtered_data2(), x = ~date_filed, y = ~word_count, type = "scatter", mode = "markers",
            marker = list(size = 10, color = ~word_count, colorscale = "Viridis",
                          showscale = TRUE),
            text = ~paste("Case:", case_name),
            hoverinfo = "text") %>%
      layout(xaxis = list(title = "Date Filed"),
             yaxis = list(title = "Opinion Length (Words)"))
  })
  
  output$opinion_length_avg <- renderText({
    avg_length <- round(mean(filtered_data2()$word_count))
    paste("Average Opinion Length:", avg_length, "words")
  })
  
  output$decision_types_plot <- renderPlotly({
    decision_counts <- filtered_data2() %>%
      count(decision) %>%
      mutate(decision = factor(decision, levels = unique(decision)))
    
    plot_ly(decision_counts, x = ~decision, y = ~n, type = "bar", color = ~decision,
            text = ~n, textposition = "auto",
            hoverinfo = "text") %>%
      layout(xaxis = list(title = "Decision Type"),
             yaxis = list(title = "Count"))
  })
  
# Create a plan for parallel execution
plan(multisession)

word_freqs <- reactive({
  req(filtered_data2())
  text <- filtered_data2()$opinions_text
  
  if (length(text) == 0) {
    return(NULL)
  }
  
  # Create a corpus from the text data
  corpus <- corpus(text)
  
  # Preprocess the text data in parallel
  corpus <- corpus %>%
    tokens(remove_punct = TRUE, remove_numbers = TRUE, remove_symbols = TRUE) %>%
    tokens_tolower() %>%
    tokens_remove(stopwords("en"))
  
  # Create a document-feature matrix
  dfm <- dfm(corpus)
  
  # Convert to data.table and compute word frequencies
  dt <- data.table(as.matrix(dfm))
  word_freqs <- dt[, lapply(.SD, sum)]
  
  # Convert to data.frame and sort by frequency
  word_freqs <- data.frame(word = colnames(word_freqs), freq = as.numeric(word_freqs))
  word_freqs <- word_freqs[order(-word_freqs$freq), ]
  
  return(word_freqs)
})

preprocessed_text <- reactive({
  req(word_freqs())
  top_words <- head(word_freqs(), 100)
  return(top_words)
})

output$interactive_word_cloud <- renderWordcloud2({
  req(preprocessed_text())
  wordcloud2(preprocessed_text(), size = 0.7, color = "random-dark", rotateRatio = 0.5, shape = "circle")
})
  
  output$sentiment_plot <- renderPlot({
    text <- filtered_data2()$opinions_text
    sentiment_scores <- get_nrc_sentiment(text)
    sentiment_sums <- colSums(sentiment_scores)
    
    barplot(sentiment_sums, main = "Sentiment Analysis",
            xlab = "Sentiment", ylab = "Count",
            col = rainbow(length(sentiment_sums)))
  })
  
  output$opinions_table <- renderDT({
    datatable(filtered_data2() %>%
                select(date_filed, case_name, decision, word_count),
              options = list(pageLength = 10),
              rownames = FALSE)
  })
  
}

shinyApp(ui, server)
```

